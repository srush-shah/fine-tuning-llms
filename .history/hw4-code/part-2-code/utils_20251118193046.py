import sqlite3
import numpy as np
import os
import re
import pickle
import random
from tqdm import tqdm

from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Any

import torch


# Get the directory where this script is located for DB path resolution
_script_dir = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(_script_dir, 'data', 'flight_database.db')

def compute_metrics(gt_path: str, model_path: str, gt_query_records: str = None, model_query_records: str = None):
    '''
    Main function to compute the three metrics used for evaluation: 
        * Exact match for SQL queries
        * Exact match for database records returned by queries
        * F1 score for database records returned by queries

    Inputs:
        * gt_path (str): The path to the ground-truth SQL queries corresponding to the text prompts
        * model_path (str): The path to SQL queries generated by the model, conditioned on the same text prompts
        * gt_query_records (str): If provided, it should be a path to a pickle file containing a list of records
                                  returned by the ground-truth SQL queries.
        * model_query_records (str): If provided, it should be a path to a pickle file containing a list of records
                                     returned by the model-generated SQL queries.
    '''
    gt_qs, gt_records, _ = load_queries_and_records(gt_path, gt_query_records)
    model_qs, model_records, model_error_msgs = load_queries_and_records(model_path, model_query_records)

    sql_em = compute_sql_exact_match(gt_qs, model_qs)
    record_em = compute_record_exact_match(gt_records, model_records)
    record_f1 = compute_record_F1(gt_records, model_records)

    return sql_em, record_em, record_f1, model_error_msgs

def load_queries_and_records(sql_path: str, record_path: str):
    '''
    Helper function for loading saved SQL queries and for computing the
    dataset records associated with said queries.

    Inputs:
        * sql_path (str): Path to a .sql file containing SQL queries
        * record_path (str): If provided, a path to a .pkl file containing dataset
                             records associated with each SQL query in sql_path.
    '''
    read_qs = read_queries(sql_path)

    if record_path is not None:
        # Handle path resolution for record_path similar to sql_path
        if not os.path.isabs(record_path) and not os.path.exists(record_path):
            script_dir = os.path.dirname(os.path.abspath(__file__))
            potential_path = os.path.join(script_dir, record_path)
            if os.path.exists(potential_path):
                record_path = potential_path
            else:
                cwd_path = os.path.abspath(record_path)
                if os.path.exists(cwd_path):
                    record_path = cwd_path
        
        if not os.path.exists(record_path):
            # Try to generate it from the corresponding SQL file
            print(f"Warning: Record file not found: {record_path}")
            print("Attempting to generate records from SQL queries...")
            # Extract the SQL path from record path (assuming naming convention)
            # For example: records/ground_truth_dev.pkl -> data/dev.sql
            record_dir = os.path.dirname(record_path)
            record_basename = os.path.basename(record_path)
            if 'ground_truth' in record_basename or 'dev' in record_basename:
                # Try to find corresponding SQL file
                if 'dev' in record_basename:
                    sql_file = os.path.join(script_dir, 'data', 'dev.sql')
                elif 'test' in record_basename:
                    sql_file = os.path.join(script_dir, 'data', 'test.sql')
                else:
                    sql_file = None
                
                if sql_file and os.path.exists(sql_file):
                    print(f"Generating records from {sql_file}...")
                    sql_queries = read_queries(sql_file)
                    records, error_msgs = compute_records(sql_queries)
                    # Save the generated records
                    os.makedirs(os.path.dirname(record_path), exist_ok=True)
                    with open(record_path, 'wb') as f:
                        pickle.dump((records, error_msgs), f)
                    print(f"Records saved to {record_path}")
                else:
                    raise FileNotFoundError(f"Record file not found: {record_path} and could not generate from SQL")
        else:
            with open(record_path, 'rb') as f:
                records, error_msgs = pickle.load(f)
    else:
        records, error_msgs = compute_records(read_qs)

    return read_qs, records, error_msgs

def clean_sql_query(query: str) -> str:
    '''
    Post-process generated SQL queries to fix common issues:
    - Remove repetitive token patterns
    - Fix malformed WHERE clauses
    - Fix invalid characters and syntax
    - Fix wrong table names and aliases
    - Ensure basic SQL syntax validity
    '''
    if not query or len(query.strip()) == 0:
        return "SELECT 1"
    
    import re
    
    # Remove invalid characters that can corrupt SQL
    query = re.sub(r'[/\\:;]', ' ', query)
    
    # Fix malformed patterns like "from/airport=" or ".airports_code:"
    query = re.sub(r'(\w+)[/\\](\w+)', r'\1.\2', query)
    query = re.sub(r'\.(\w+):', r'.\1', query)
    
    # Remove excessive repetition (e.g., "service_service_service" -> "service")
    # Pattern to find repeated words/phrases (3+ repetitions)
    query = re.sub(r'(\b\w+_?\w*\b)(\s*\1){2,}', r'\1', query)
    
    # Fix common table name errors (based on observed patterns)
    # airport_provider -> airport_service
    query = re.sub(r'\bairport_provider(\d*)', r'airport_service\1', query, flags=re.IGNORECASE)
    # plane_1 -> flight_1 (when used as table, but keep as alias if it's plane table)
    # airline_1 -> airport_service_1 (common mistake)
    query = re.sub(r'\bairline_(\d+)', r'airport_service_\1', query, flags=re.IGNORECASE)
    # transport_* -> airport_service_* (common mistake)
    query = re.sub(r'\btransport_(\d+)', r'airport_service_\1', query, flags=re.IGNORECASE)
    # flights_* -> flight_* (plural to singular)
    query = re.sub(r'\bflights_(\d+)', r'flight_\1', query, flags=re.IGNORECASE)
    
    # Extract FROM clause to identify correct aliases
    from_match = re.search(r'FROM\s+([^WHERE]+?)(?:\s+WHERE|$)', query, re.IGNORECASE)
    if from_match:
        from_clause = from_match.group(1)
        # Find all table aliases defined in FROM clause
        # Pattern: table_name alias_name
        alias_pattern = r'(\w+)\s+(\w+_\d+)'
        defined_aliases = set()
        for match in re.finditer(alias_pattern, from_clause):
            table_name, alias = match.group(1), match.group(2)
            defined_aliases.add(alias)
        
        # Fix wrong aliases in WHERE clause
        # If flight_1 is defined but we see flight_2, flight_3, etc., replace with flight_1
        if 'flight_1' in defined_aliases:
            # Replace flight_2, flight_3, etc. with flight_1 (but not flight_1 itself)
            query = re.sub(r'\bflight_([2-9]|\d{2,})\b', 'flight_1', query)
        
        # Fix wrong table references: if we see airport_1 but airport_service_1 is defined, fix it
        if 'airport_service_1' in defined_aliases:
            query = re.sub(r'\bairport_1\.', 'airport_service_1.', query)
        if 'airport_service_2' in defined_aliases:
            query = re.sub(r'\bairport_2\.', 'airport_service_2.', query)
        if 'airport_service_3' in defined_aliases:
            query = re.sub(r'\bairport_3\.', 'airport_service_3.', query)
        
        # Fix city aliases similarly
        if 'city_1' in defined_aliases:
            query = re.sub(r'\bcity_([2-9]|\d{2,})\b', lambda m: 'city_' + str(int(m.group(1)) if m.group(1).isdigit() else 1), query)
        # But be careful - city_2, city_3 might be valid if defined
        # So only fix if they're used but not defined
        for i in range(2, 10):
            city_alias = f'city_{i}'
            if city_alias not in defined_aliases and city_alias in query:
                # If city_2 is used but not defined, and city_1 is defined, use city_1
                if 'city_1' in defined_aliases:
                    query = re.sub(rf'\b{city_alias}\b', 'city_1', query)
    
    # Fix multiple consecutive equals signs
    query = re.sub(r'=\s*=\s*=', '=', query)
    query = re.sub(r'=\s*=', '=', query)
    
    # Fix patterns like "column1 = column2 = value" -> "column1 = value AND column2 = value"
    # This is a common error pattern
    query = re.sub(r'(\w+\.\w+)\s*=\s*(\w+\.\w+)\s*=\s*([\'"]?\w+[\'"]?)', r'\1 = \3 AND \2 = \3', query)
    
    # Fix incomplete WHERE clauses - remove trailing incomplete conditions
    # Pattern: ends with incomplete conditions like "AND(", "AND )", "= )", etc.
    query = re.sub(r'\s+AND\s*\(\s*\)\s*$', '', query)
    query = re.sub(r'\s+=\s*\)\s*$', '', query)
    query = re.sub(r'\s+AND\s*\(\s*$', '', query)
    
    # Fix malformed column references
    # Pattern: "flight_1.from_airport" should exist, but "flight_2.from_airport" is wrong
    # We already fixed flight_2 -> flight_1 above, but check for other issues
    # Fix: "airport_1.airport_code" when it should be "airport_service_1.airport_code"
    query = re.sub(r'\bairport_(\d+)\.airport_code\b', r'airport_service_\1.airport_code', query)
    
    # Remove excessive whitespace
    query = ' '.join(query.split())
    
    # Ensure query starts with SELECT (basic validation)
    if not query.upper().startswith('SELECT'):
        # Try to extract SQL from malformed output
        select_match = re.search(r'SELECT.*', query, re.IGNORECASE)
        if select_match:
            query = select_match.group(0)
        else:
            return "SELECT 1"
    
    # Basic validation: ensure FROM clause exists
    if 'FROM' not in query.upper() and 'SELECT' in query.upper():
        # Try to add a minimal FROM clause if missing
        select_part = query.split('WHERE')[0] if 'WHERE' in query else query
        if 'FROM' not in select_part.upper():
            return "SELECT 1"  # Too malformed to fix
    
    # Remove trailing incomplete parentheses and malformed endings
    query = re.sub(r'\s*\(\s*\)\s*$', '', query)
    query = re.sub(r'\s*\)\s*\)\s*$', ' )', query)
    
    return query.strip()

def save_queries_and_records(sql_queries: List[str], sql_path: str, record_path: str):
    '''
    Helper function to save model generated SQL queries and their associated records
    to the specified paths.

    Inputs: 
        * sql_queries (List[str]): The list of SQL queries to save
        * sql_path (str): Path to save SQL queries
        * record_path (str): Path to save database records associated with queries
    '''
    sql_dir = os.path.dirname(sql_path)
    record_dir = os.path.dirname(record_path)
    if sql_dir:  # Only create if there's a directory component
        os.makedirs(sql_dir, exist_ok=True)
    if record_dir:  # Only create if there's a directory component
        os.makedirs(record_dir, exist_ok=True)
    
    # Clean SQL queries before saving
    cleaned_queries = [clean_sql_query(q) for q in sql_queries]
    
    # First save the queries
    with open(sql_path, 'w') as f:
        for query in cleaned_queries:
            f.write(f'{query}\n')

    # Next compute and save records
    records, error_msgs = compute_records(cleaned_queries)    
    with open(record_path, 'wb') as f:
        pickle.dump((records, error_msgs), f)

def read_queries(sql_path: str):
    # Handle both absolute and relative paths
    if not os.path.isabs(sql_path) and not os.path.exists(sql_path):
        # If relative path doesn't exist, try to resolve it relative to the script directory
        script_dir = os.path.dirname(os.path.abspath(__file__))
        potential_path = os.path.join(script_dir, sql_path)
        if os.path.exists(potential_path):
            sql_path = potential_path
        else:
            # Try resolving from current working directory
            cwd_path = os.path.abspath(sql_path)
            if os.path.exists(cwd_path):
                sql_path = cwd_path
    
    if not os.path.exists(sql_path):
        raise FileNotFoundError(f"SQL file not found: {sql_path}")
    with open(sql_path, 'r') as f:
        qs = [q.strip() for q in f.readlines()]
    return qs

def compute_records(processed_qs: List[str]):
    '''
    Helper function for computing the records associated with each SQL query in the
    input list. You may change the number of threads or the timeout variable (in seconds)
    based on your computational constraints.

    Input:
        * processed_qs (List[str]): The list of SQL queries to execute
    '''
    num_threads = 10
    timeout_secs = 120

    pool = ThreadPoolExecutor(num_threads)
    futures = []
    for i, query in enumerate(processed_qs):
        futures.append(pool.submit(compute_record, i, query))
        
    rec_dict = {}
    try:
        for x in tqdm(as_completed(futures, timeout=timeout_secs)):
            query_id, rec, error_msg = x.result()
            rec_dict[query_id] = (rec, error_msg)
    except:
        for future in futures:
            if not future.done():
                future.cancel()
            
    recs = []
    error_msgs = []
    for i in range(len(processed_qs)):
        if i in rec_dict:
            rec, error_msg = rec_dict[i]
            recs.append(rec)
            error_msgs.append(error_msg)
        else:
            recs.append([])
            error_msgs.append("Query timed out")
            
    return recs, error_msgs

def compute_record(query_id, query):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    try:
        cursor.execute(query)
        rec = cursor.fetchall()
        error_msg = ""
    except Exception as e:
        rec = []
        error_msg = f"{type(e).__name__}: {e}"

    conn.close()
    return query_id, rec, error_msg

def compute_sql_exact_match(gt_qs: List[str], model_qs: List[str]):
    '''
    Helper function to compute exact match between ground-truth
    and model generated SQL queries.
    '''
    total = 0
    ems = 0
    for gt_q, model_q in zip(gt_qs, model_qs):
        total += 1
        ems += 1 if gt_q == model_q else 0
    return ems / total

def compute_record_exact_match(gt_records: List[Any], model_records: List[Any]):
    '''
    Helper function to compute exact match between records
    generated by ground-truth and model SQL queries
    '''
    total = 0
    ems = 0
    for gt_rec, model_rec in zip(gt_records, model_records):
        total += 1
        ems += 1 if set(gt_rec) == set(model_rec) else 0
    return ems / total

def compute_record_F1(gt_records: List[Any], model_records: List[Any]):
    '''
    Helper function to compute F1 between records
    generated by ground-truth and model SQL queries
    '''
    F1s = []
    for gt_rec, model_rec in zip(gt_records, model_records):
        gt_set = set(gt_rec)
        model_set = set(model_rec)        

        precision_total = len(model_set)
        if precision_total == 0:
            precision = 1
        else:
            precision = len([rec for rec in model_set if rec in gt_set]) / precision_total
    
        recall_total = len(gt_set)    
        if recall_total == 0:
            recall = 1
        else:
            recall = len([rec for rec in gt_set if rec in model_set]) / recall_total

        F1 = 2 * precision * recall / (precision + recall + 1e-8)
        F1s.append(F1)

    return np.mean(F1s)

def set_random_seeds(seed_value=42):
    '''
    Set random seeds for better reproducibility
    '''
    random.seed(seed_value)
    np.random.seed(seed_value)
    
    torch.manual_seed(seed_value)
    torch.cuda.manual_seed(seed_value)
    torch.cuda.manual_seed_all(seed_value)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
